using System;
using Entities.Player;
using NaughtyAttributes;
using UnityEngine;

namespace Weapons
{
    /// <summary>
    /// Manages a single weapon.
    /// If the heat generated by the weapon exceeds a certain threshold, the weapon will overheat and be unusable for a short time.
    /// </summary>
    public class WeaponObject : MonoBehaviour
    {
        // private const float HEAT_THRESHOLD = 100f;
        
        [Header("References")]
        
        [SerializeField]
        private Transform _projectileSpawnPoint;
        
        /*[ReadOnly, SerializeField]
        private float _currentHeat;
        [ReadOnly, SerializeField]
        private float _overheatCooldownLeft;*/
        [ReadOnly, SerializeField]
        private float _fireDelayLeft;
        
        public ProjectileBehaviour DynamicBehaviour { get; private set; } = new(Array.Empty<ProjectileEventData>());
        private IDamageCauser _owner;
        private RuntimeWeaponData _runtimeData;
        
        
        public void Initialize(RuntimeWeaponData data, IDamageCauser owner)
        {
            _runtimeData?.DropAllEventItems(transform.position);
            _runtimeData = data;
            _owner = owner;
            DynamicBehaviour = new ProjectileBehaviour(_runtimeData.Events);
            SetEvents(_runtimeData.Events);
        }


        public void SetEvents(ProjectileEventData[] projectileEventData)
        {
            _runtimeData.OverwriteEvents(projectileEventData);
            DynamicBehaviour = new ProjectileBehaviour(_runtimeData.Events);
        }


        private void Update()
        {
            /*// Handle overheating.
            if (_overheatCooldownLeft > 0f)
            {
                _overheatCooldownLeft -= Time.deltaTime;
                _currentHeat = 0f;
            }
            else
            {
                _currentHeat -= _heatRemovedPerSecond * Time.deltaTime;
                if (_currentHeat < 0f)
                {
                    _currentHeat = 0f;
                }
            }*/
            
            // Handle firing delay.
            if (_fireDelayLeft > 0f)
            {
                _fireDelayLeft -= Time.deltaTime;
            }
        }
        
        
        public void TryFire()
        {
            if (_fireDelayLeft > 0f)
                return;
            
            if (DynamicBehaviour.EventCount <= 0)
                return;
            
            /*if (_overheatCooldownLeft > 0f)
                return;
            
            if (_currentHeat >= HEAT_THRESHOLD)
            {
                _overheatCooldownLeft = _overheatCooldownSeconds;
                return;
            }
            
            _currentHeat += _generatedHeatPerShot;*/
            Fire();
            _fireDelayLeft = 60f / _runtimeData.Weapon.FireRateRpm;
        }


        private void Fire()
        {
            Projectile p = Instantiate(_runtimeData.Weapon.ProjectilePrefab, _projectileSpawnPoint.position, _projectileSpawnPoint.rotation);
            p.Initialize(DynamicBehaviour, _owner, 0);
        }
    }
}